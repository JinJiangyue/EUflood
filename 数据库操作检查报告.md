# 数据库操作检查报告

## 数据库配置

### 数据库类型
- **SQLite** (使用 `better-sqlite3` 库)
- 数据库文件路径：`apps/database/dev.db` (默认)
- 可通过环境变量 `DB_FILE` 配置

### 数据库连接
- **文件位置**: `apps/api/src/db.ts`
- **连接库**: `better-sqlite3`
- **WAL模式**: 已启用 (`PRAGMA journal_mode = WAL`)
- **外键约束**: 已启用 (`PRAGMA foreign_keys = ON`)

---

## 数据库表结构

### 1. `rain_event` 表（降雨事件表）
**用途**: 存储降雨事件原始数据

**字段**:
- `id` (TEXT PRIMARY KEY) - 事件ID，格式：YYYYMMDD_Province_seq
- `date` (TEXT NOT NULL) - 日期
- `country` (TEXT) - 国家
- `province` (TEXT NOT NULL) - 省份
- `city` (TEXT) - 城市
- `longitude` (REAL NOT NULL) - 经度
- `latitude` (REAL NOT NULL) - 纬度
- `value` (REAL) - 降雨值
- `threshold` (REAL) - 阈值
- `return_period_band` (TEXT) - 重现期区间
- `return_period_estimate` (REAL) - 重现期估计值
- `file_name` (TEXT NOT NULL) - 文件名
- `seq` (INTEGER) - 序号
- `searched` (INTEGER DEFAULT 0) - 搜索状态：0=未搜索，1=已搜索，2=需重搜

**索引**:
- `idx_re_date` - 日期索引
- `idx_re_region` - 省份索引
- `idx_re_value` - 降雨值索引
- `uniq_rain_event_dupe` - 唯一索引（date, file_name, longitude, latitude）

### 2. `rain_flood_impact` 表（降雨洪水影响汇总表）
**用途**: 存储降雨事件的洪水影响评估结果

**字段**:
- `id` (INTEGER PRIMARY KEY AUTOINCREMENT)
- `rain_event_id` (TEXT NOT NULL UNIQUE) - 关联 rain_event.id
- `date` (TEXT) - 日期
- `level` (INTEGER) - 影响级别
- `country` (TEXT) - 国家
- `province` (TEXT) - 省份
- `city` (TEXT) - 城市
- `transport_impact_level` (INTEGER) - 交通影响级别
- `economy_impact_level` (INTEGER) - 经济影响级别
- `safety_impact_level` (INTEGER) - 安全影响级别
- `timeline_data` (TEXT) - 时间线数据（JSON字符串）
- `source_count` (INTEGER) - 来源数量
- `detail_file` (TEXT) - 详细报告文件路径
- `created_at` (TEXT DEFAULT datetime('now'))
- `updated_at` (TEXT DEFAULT datetime('now'))

**索引**:
- `idx_rain_flood_impact_rain_event_id` - 事件ID索引
- `idx_rain_flood_impact_level` - 级别索引
- `idx_rain_flood_impact_country` - 国家索引
- `idx_rain_flood_impact_province` - 省份索引

### 3. `merged_flood_events` 表（合并洪水事件表）
**用途**: 存储从多个平台合并的洪水事件

**字段**:
- `id` (INTEGER PRIMARY KEY AUTOINCREMENT)
- `global_event_key` (TEXT UNIQUE) - 全局事件键
- `event_date` (TEXT NOT NULL) - 事件日期
- `country` (TEXT NOT NULL) - 国家
- `city` (TEXT) - 城市
- `latitude` (REAL) - 纬度
- `longitude` (REAL) - 经度
- `time_from` (TEXT) - 开始时间
- `time_to` (TEXT) - 结束时间
- `severity` (TEXT) - 严重程度
- `level` (INTEGER) - 级别
- `sources` (TEXT) - 数据源列表（JSON）
- `source_count` (INTEGER DEFAULT 1) - 数据源数量
- `titles` (TEXT) - 标题列表（JSON）
- `descriptions` (TEXT) - 描述列表（JSON）
- `source_urls` (TEXT) - 来源URL列表（JSON）
- `enriched` (BOOLEAN DEFAULT 0) - 是否已丰富
- `enriched_at` (TEXT) - 丰富时间
- `created_at` (TEXT DEFAULT datetime('now'))

**索引**:
- `idx_merged_events_date` - 日期索引
- `idx_merged_events_country` - 国家索引
- `idx_merged_events_global_key` - 全局键索引

---

## 数据库操作详细列表

### 一、表结构操作（DDL）

#### 1. 表创建和初始化
**文件**: `apps/api/src/db.ts`

```typescript
// 创建 rain_event 表
CREATE TABLE IF NOT EXISTS rain_event (...)
CREATE INDEX IF NOT EXISTS idx_re_date ON rain_event(date)
CREATE INDEX IF NOT EXISTS idx_re_region ON rain_event(province)
CREATE INDEX IF NOT EXISTS idx_re_value ON rain_event(value)
CREATE UNIQUE INDEX IF NOT EXISTS uniq_rain_event_dupe ON rain_event(date, file_name, longitude, latitude)

// 创建 rain_flood_impact 表
CREATE TABLE IF NOT EXISTS rain_flood_impact (...)
CREATE INDEX IF NOT EXISTS idx_rain_flood_impact_rain_event_id ON rain_flood_impact(rain_event_id)
CREATE INDEX IF NOT EXISTS idx_rain_flood_impact_level ON rain_flood_impact(level)
CREATE INDEX IF NOT EXISTS idx_rain_flood_impact_country ON rain_flood_impact(country)
CREATE INDEX IF NOT EXISTS idx_rain_flood_impact_province ON rain_flood_impact(province)

// 创建 merged_flood_events 表（动态创建）
CREATE TABLE merged_flood_events (...)
CREATE INDEX IF NOT EXISTS idx_merged_events_date ON merged_flood_events(event_date)
CREATE INDEX IF NOT EXISTS idx_merged_events_country ON merged_flood_events(country)
CREATE INDEX IF NOT EXISTS idx_merged_events_global_key ON merged_flood_events(global_event_key)
```

#### 2. 表结构升级
**文件**: `apps/api/src/db.ts`

```typescript
// 检查表是否存在
SELECT name FROM sqlite_master WHERE type='table' AND name='rain_event'

// 检查列是否存在
PRAGMA table_info(rain_event)

// 添加新列
ALTER TABLE rain_event ADD COLUMN searched INTEGER DEFAULT 0
ALTER TABLE rain_event ADD COLUMN return_period_band TEXT
ALTER TABLE rain_event ADD COLUMN return_period_estimate REAL
```

---

### 二、查询操作（SELECT）

#### 1. 降雨事件查询
**文件**: `apps/api/src/modules/events/rain-routes.ts`

##### 1.1 获取最新降雨事件
```typescript
SELECT id, date, country, province, city, longitude, latitude, value, threshold, 
       return_period_band, return_period_estimate, file_name, seq, searched
FROM rain_event
ORDER BY date DESC, country ASC, province ASC, seq ASC
LIMIT ?
```

##### 1.2 按日期范围和国家查询降雨事件（分组统计）
```typescript
SELECT date, country, province,
       COUNT(*) as event_count,
       COUNT(CASE WHEN searched = 1 THEN 1 END) as searched_count,
       COUNT(CASE WHEN searched = 0 THEN 1 END) as unsearched_count,
       COUNT(CASE WHEN searched = 2 THEN 1 END) as need_research_count,
       AVG(value) as avg_value,
       MAX(value) as max_value,
       MIN(value) as min_value
FROM rain_event
WHERE date >= ? AND date <= ? [AND country条件]
GROUP BY date, country, province
ORDER BY date DESC, country ASC, province ASC
```

##### 1.3 查询降雨事件总数（分页）
```typescript
SELECT COUNT(*) as total FROM rain_event WHERE [条件]
```

##### 1.4 查询降雨事件详情（分页）
```typescript
SELECT id, date, country, province, city, longitude, latitude, value, threshold, 
       return_period_band, return_period_estimate, file_name, seq, searched
FROM rain_event
WHERE [条件]
ORDER BY date DESC, country ASC, province ASC, seq ASC
LIMIT ? OFFSET ?
```

##### 1.5 查询统计信息
```typescript
SELECT COUNT(*) as total_events,
       COUNT(DISTINCT date) as date_count,
       COUNT(DISTINCT country) as country_count,
       COUNT(DISTINCT province) as province_count,
       COUNT(CASE WHEN searched = 1 THEN 1 END) as total_searched,
       COUNT(CASE WHEN searched = 0 THEN 1 END) as total_unsearched,
       COUNT(CASE WHEN searched = 2 THEN 1 END) as total_need_research
FROM rain_event
WHERE [条件]
```

##### 1.6 获取单个降雨事件
```typescript
SELECT * FROM rain_event WHERE id = ?
```

##### 1.7 查询洪水影响数据
```typescript
SELECT * FROM rain_flood_impact WHERE rain_event_id = ?
```

#### 2. 统计分析查询
**文件**: `apps/api/src/modules/analysis/routes.ts`

##### 2.1 统计降雨事件总数
```typescript
SELECT COUNT(*) AS total FROM rain_event
```

##### 2.2 统计已搜索事件数
```typescript
SELECT COUNT(*) AS cnt FROM rain_event WHERE searched = 1
```

##### 2.3 统计未搜索事件数
```typescript
SELECT COUNT(*) AS cnt FROM rain_event WHERE searched = 0
```

##### 2.4 统计洪水影响总数
```typescript
SELECT COUNT(*) AS total FROM rain_flood_impact
```

##### 2.5 统计平均影响级别
```typescript
SELECT AVG(level) AS avg_level FROM rain_flood_impact WHERE level IS NOT NULL
```

##### 2.6 统计最大影响级别
```typescript
SELECT MAX(level) AS max_level FROM rain_flood_impact WHERE level IS NOT NULL
```

##### 2.7 统计平均降雨值
```typescript
SELECT AVG(value) AS avg_value FROM rain_event WHERE value IS NOT NULL
```

##### 2.8 统计最大降雨值
```typescript
SELECT MAX(value) AS max_value FROM rain_event WHERE value IS NOT NULL
```

#### 3. 合并事件查询
**文件**: `apps/api/src/modules/events/merger.ts`, `apps/api/src/modules/events/merger-routes.ts`

##### 3.1 查询合并事件
```typescript
SELECT id, global_event_key, event_date, country, city, latitude, longitude,
       time_from, time_to, severity, level, sources, source_count,
       titles, descriptions, source_urls, enriched, created_at
FROM merged_flood_events
WHERE event_date >= ? AND event_date <= ?
ORDER BY event_date DESC, level DESC, severity DESC, source_count DESC
```

##### 3.2 查询单个合并事件
```typescript
SELECT * FROM merged_flood_events WHERE id = ?
```

#### 4. Python 端的查询操作
**文件**: `search/llm/db_writer.py`, `search/watcher/rain_event_watcher.py`

##### 4.1 从数据库获取降雨事件
```python
SELECT * FROM rain_event WHERE id = ?
SELECT * FROM rain_event WHERE id LIKE ?  # 模糊匹配
SELECT id FROM rain_event WHERE id LIKE ? LIMIT 5  # 查找相似ID
```

##### 4.2 查询待处理的降雨事件
```python
SELECT * FROM rain_event 
WHERE searched IS NULL OR searched = 0
```

---

### 三、插入操作（INSERT）

#### 1. 插入洪水影响数据
**文件**: `search/llm/db_writer.py`

```python
INSERT INTO rain_flood_impact (
    rain_event_id, date, level,
    country, province, city,
    transport_impact_level, economy_impact_level, safety_impact_level,
    timeline_data, source_count, detail_file,
    created_at, updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
ON CONFLICT(rain_event_id) DO UPDATE SET
    date = excluded.date,
    level = excluded.level,
    country = excluded.country,
    province = excluded.province,
    city = excluded.city,
    transport_impact_level = excluded.transport_impact_level,
    economy_impact_level = excluded.economy_impact_level,
    safety_impact_level = excluded.safety_impact_level,
    timeline_data = excluded.timeline_data,
    source_count = excluded.source_count,
    detail_file = excluded.detail_file,
    updated_at = datetime('now')
```

#### 2. 插入合并事件
**文件**: `apps/api/src/modules/events/merger.ts`

```typescript
INSERT INTO merged_flood_events (
    global_event_key, event_date, country, city, latitude, longitude,
    time_from, time_to, severity, level,
    sources, source_count, titles, descriptions, source_urls,
    enriched, created_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'))
ON CONFLICT(global_event_key) DO UPDATE SET
    source_count = excluded.source_count,
    sources = excluded.sources,
    titles = excluded.titles,
    descriptions = excluded.descriptions,
    source_urls = excluded.source_urls,
    severity = excluded.severity,
    level = excluded.level
```

---

### 四、更新操作（UPDATE）

#### 1. 更新搜索状态
**文件**: `apps/api/src/modules/events/rain-routes.ts`

##### 1.1 更新单个事件的搜索状态
```typescript
UPDATE rain_event SET searched = ? WHERE id = ?
```

##### 1.2 深度搜索成功后更新状态为已搜索
```typescript
UPDATE rain_event SET searched = 1 WHERE id = ?
```

##### 1.3 深度搜索失败后更新状态为需重搜
```typescript
UPDATE rain_event SET searched = 2 WHERE id = ?
```

#### 2. Python 端更新操作
**文件**: `search/llm/db_writer.py`, `search/orchestrator/workflow.py`

##### 2.1 填充表2成功后更新表1状态
```python
UPDATE rain_event SET searched = 1 WHERE id = ?
```

##### 2.2 填充表2失败后更新表1状态
```python
UPDATE rain_event SET searched = 2 WHERE id = ?
```

##### 2.3 标记事件为已处理
**文件**: `search/watcher/rain_event_watcher.py`
```python
UPDATE rain_event SET searched = 1, processed_at = ? WHERE id = ?
```

---

### 五、删除操作（DELETE）

**当前代码中未发现 DELETE 操作**

---

### 六、事务操作

#### 1. Node.js 端事务
**文件**: `apps/api/src/modules/ingestion/service.ts`, `apps/api/src/modules/processing/service.ts`

```typescript
// 使用 better-sqlite3 的事务
const txn = db.transaction((items) => {
    for (const item of items) {
        // 执行多个操作
    }
});
txn(items);
```

---

## 操作统计

### 按操作类型统计

| 操作类型 | 数量 | 主要文件 |
|---------|------|---------|
| SELECT | 20+ | rain-routes.ts, analysis/routes.ts, merger.ts, db_writer.py |
| INSERT | 2 | db_writer.py, merger.ts |
| UPDATE | 10+ | rain-routes.ts, db_writer.py, workflow.py |
| DELETE | 0 | - |
| DDL | 10+ | db.ts, merger.ts |

### 按表统计

| 表名 | SELECT | INSERT | UPDATE | DELETE |
|------|--------|--------|--------|--------|
| `rain_event` | 15+ | 0 | 10+ | 0 |
| `rain_flood_impact` | 5+ | 1 | 0 | 0 |
| `merged_flood_events` | 2 | 1 | 0 | 0 |

---

## 潜在问题和建议

### 1. 已废弃的代码
- `flood_records` 表相关操作已注释，但代码仍存在
- `apps/api/src/modules/ingestion/service.ts` - 已禁用
- `apps/api/src/modules/search/routes.ts` - 已禁用
- `apps/api/src/modules/processing/service.ts` - 已禁用
- `apps/api/src/modules/trigger/service.ts` - 已禁用

**建议**: 清理废弃代码，避免混淆

### 2. 数据库连接管理
- Node.js 端使用 `better-sqlite3`，连接是单例模式
- Python 端每次操作都创建新连接

**建议**: Python 端考虑使用连接池或上下文管理器优化

### 3. 错误处理
- 大部分操作都有 try-catch，但错误处理不够统一
- 某些操作失败后没有回滚机制

**建议**: 统一错误处理机制，关键操作使用事务

### 4. 数据一致性
- 表1和表2之间的状态同步依赖应用层逻辑
- `searched` 字段的更新分散在多个地方

**建议**: 考虑使用数据库触发器或统一的状态管理函数

### 5. 性能优化
- 某些查询可能缺少索引
- 分页查询可以进一步优化

**建议**: 定期检查慢查询，添加必要的索引

---

## 总结

项目使用 SQLite 数据库，主要包含三个表：
1. **rain_event** - 降雨事件原始数据
2. **rain_flood_impact** - 洪水影响评估结果
3. **merged_flood_events** - 合并的洪水事件

数据库操作主要集中在：
- **查询操作**：大量 SELECT 查询用于数据展示和统计
- **更新操作**：主要用于更新搜索状态
- **插入操作**：用于保存处理结果

整体架构清晰，但存在一些废弃代码需要清理，建议优化错误处理和性能。

